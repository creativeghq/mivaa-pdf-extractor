name: Deploy FastAPI App

on:
  workflow_call:
    inputs:
      image_tag:
        required: true
        type: string
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy'
        required: false
        default: 'latest'
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      # 1. Setup SSH
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_SSH_KEY }}

      # 2. Deploy to server
      - name: Deploy to server
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_ANON_KEY: ${{ secrets.SUPABASE_ANON_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          MATERIAL_KAI_API_URL: ${{ secrets.MATERIAL_KAI_API_URL }}
          MATERIAL_KAI_API_KEY: ${{ secrets.MATERIAL_KAI_API_KEY }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
        run: |
          IMAGE_TAG="${{ inputs.image_tag }}"
          
          # Create deployment script
          cat > deploy_script.sh << 'SCRIPT_EOF'
          #!/bin/bash
          set -e
          
          # Environment variables will be passed via SSH
          GH_TOKEN="$1"
          GITHUB_ACTOR="$2"
          IMAGE_TAG="$3"
          GITHUB_REPOSITORY="$4"
          SUPABASE_URL="$5"
          SUPABASE_ANON_KEY="$6"
          OPENAI_API_KEY="$7"
          MATERIAL_KAI_API_URL="$8"
          MATERIAL_KAI_API_KEY="$9"
          SENTRY_DSN="${10}"
          
          # Find the correct directory
          if [ -d "/opt/mivaa-pdf-extractor" ]; then
            APP_DIR="/opt/mivaa-pdf-extractor"
          elif [ -d "/var/www/mivaa-pdf-extractor" ]; then
            APP_DIR="/var/www/mivaa-pdf-extractor"
          else
            echo "📁 Creating directory: /var/www/mivaa-pdf-extractor"
            mkdir -p /var/www/mivaa-pdf-extractor
            APP_DIR="/var/www/mivaa-pdf-extractor"
          fi
          
          echo "📁 Using directory: $APP_DIR"
          cd "$APP_DIR"
          
          # Check if Docker is installed
          if ! command -v docker &> /dev/null; then
            echo "🐳 Installing Docker..."
            
            # Update package index
            apt-get update
            
            # Install packages to allow apt to use a repository over HTTPS
            apt-get install -y \
              ca-certificates \
              curl \
              gnupg \
              lsb-release
            
            # Add Docker's official GPG key
            mkdir -p /etc/apt/keyrings
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            
            # Set up the repository
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            
            # Update package index again
            apt-get update
            
            # Install Docker Engine
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            
            # Enable and start Docker
            systemctl enable docker
            systemctl start docker
            
            echo "✅ Docker installed successfully"
          else
            echo "✅ Docker already installed"
          fi
          
          # Check if Docker Compose is installed
          if ! command -v docker-compose &> /dev/null; then
            echo "🐳 Installing Docker Compose..."
            DOCKER_COMPOSE_VERSION="v2.24.1"
            curl -L "https://github.com/docker/compose/releases/download/${DOCKER_COMPOSE_VERSION}/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose
            echo "✅ Docker Compose installed successfully"
          fi
          
          # Ensure Docker is running
          if ! systemctl is-active --quiet docker; then
            echo "🔄 Starting Docker service..."
            systemctl start docker
          fi
          
          echo "🔐 Authenticating with GitHub Container Registry..."
          echo "$GH_TOKEN" | docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin
          
          echo "🔧 Setting up environment variables for Docker..."
          export GITHUB_REPOSITORY="$GITHUB_REPOSITORY"
          export IMAGE_TAG="$IMAGE_TAG"
          export SUPABASE_URL="$SUPABASE_URL"
          export SUPABASE_ANON_KEY="$SUPABASE_ANON_KEY"
          export OPENAI_API_KEY="$OPENAI_API_KEY"
          export MATERIAL_KAI_API_URL="$MATERIAL_KAI_API_URL"
          export MATERIAL_KAI_API_KEY="$MATERIAL_KAI_API_KEY"
          export SENTRY_DSN="$SENTRY_DSN"
          
          echo "🐳 Pulling image: ghcr.io/$GITHUB_REPOSITORY/mivaa-pdf-extractor:$IMAGE_TAG"
          
          # Create docker-compose.yml if it doesn't exist
          if [ ! -f "docker-compose.yml" ]; then
            echo "📝 Creating docker-compose.yml..."
            cat > docker-compose.yml << 'COMPOSE_EOF'
          services:
            mivaa-pdf-extractor:
              image: ghcr.io/\${GITHUB_REPOSITORY}/mivaa-pdf-extractor:\${IMAGE_TAG}
              container_name: mivaa-pdf-extractor
              restart: unless-stopped
              ports:
                - "8000:8000"
              environment:
                - ENVIRONMENT=production
                - SUPABASE_URL=\${SUPABASE_URL}
                - SUPABASE_ANON_KEY=\${SUPABASE_ANON_KEY}
                - OPENAI_API_KEY=\${OPENAI_API_KEY}
                - SENTRY_DSN=\${SENTRY_DSN}
                - MATERIAL_KAI_API_URL=\${MATERIAL_KAI_API_URL}
                - MATERIAL_KAI_API_KEY=\${MATERIAL_KAI_API_KEY}
              volumes:
                - ./logs:/app/logs
                - ./uploads:/app/uploads
                - ./temp:/app/temp
              networks:
                - mivaa-network
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          
          networks:
            mivaa-network:
              driver: bridge
          COMPOSE_EOF
          fi
          
          # Create necessary directories
          mkdir -p logs uploads temp
          
          # Pull and start containers
          docker-compose pull
          docker-compose up -d
          
          # Wait and verify
          echo "⏳ Waiting for containers..."
          sleep 15
          
          if docker-compose ps | grep -q "Exit"; then
            echo "::error::Container failed to start"
            docker-compose ps
            docker-compose logs --tail=20
            exit 1
          fi
          
          echo "✅ Deployment completed"
          SCRIPT_EOF
          
          # Make script executable and copy to server
          chmod +x deploy_script.sh
          scp -o StrictHostKeyChecking=no deploy_script.sh root@104.248.68.3:/tmp/
          
          # Execute deployment script on server
          ssh -o StrictHostKeyChecking=no root@104.248.68.3 \
            "/tmp/deploy_script.sh '$GH_TOKEN' '${{ github.actor }}' '$IMAGE_TAG' '${{ github.repository }}' '$SUPABASE_URL' '$SUPABASE_ANON_KEY' '$OPENAI_API_KEY' '$MATERIAL_KAI_API_URL' '$MATERIAL_KAI_API_KEY' '$SENTRY_DSN'"

      # 3. Verify deployment
      - name: Verify deployment
        run: |
          echo "🔍 Verifying deployment..."
          
          # Test health endpoint
          for i in {1..6}; do
            if curl -f -s http://104.248.68.3:8000/health > /dev/null; then
              echo "✅ Health check passed"
              break
            elif [ $i -eq 6 ]; then
              echo "::error::Health check failed after 6 attempts"
              exit 1
            else
              echo "⏳ Health check attempt $i failed, retrying..."
              sleep 10
            fi
          done
          
          echo "🎉 Deployment verified successfully"
